# 图
`2019.05.01 by jianfeng`

[知识来源：CSDN -> **键盘上的钢琴师_v5**](https://blog.csdn.net/daijin888888/article/details/73177325)
-----------------------------------------------------
### 简介
- 图是由顶点的有穷非空集合和顶点之间的边的集合组成
- 通常表示为：G = <V, E)
    > G表示图，V表示G图中顶点的集合，E表示图G中边的集合
- 相关数据结构的特点
    1. 线性结构——每个元素只有一个直接前驱和直接后继
    2. 树结构——数据元素（节点）间有明显的层次关系
    3. 图结构——数据元素（顶点）间具有任意的关系

### 相关概念
- 无向边
    - 通常用无序偶对(Vi, Vj)来表示
    > 例如：G=(V1,{E1}),其中顶点集合V1={A,B,C},边的集合E1={(A,B),(B,C),(B,A),(C,A)}
- 有向边 (也称之为"弧")
    - 通常使用有序对<Vi, Vj>来表示
    > 例如：G=(V2,{E2}),其中顶点集合V2={A,B,C},弧的集合E2={<A,B>,<B,C>,<B,A>,<C,A>}

- 简单图 **（当前学的是简单图）**
    > 不存在顶点到自身的边且同一条边不重复的出现

- 无向完全图
    > 任意的两个顶点都存在边
    - n个顶点的无向完全图有n*(n-1)/2条边
- 有向完全图
    > 任意两个顶点之间都存在方向互为相反的两条弧，
    - n个顶点的有向完全图有n*(n-1)条边

- 稀疏图
- 稠密图

- 权
    > 边or弧的参数
- 网
    > 带权的图

- 子图
    > G=(V,{E}),G'=(V',{E'})。若V'是V的子集，E'是E的子集。则G'是G的子图


### 无向图 G=(V,{E})
- 若(v,v')属于E，则
    - v和v'互为邻接点
    - (v,v')与顶点v和v'相关联
- 顶点v的度
    > 和v相关联的边的数目，几位TD(v)

### 有向图 G=<V,{E}>
- 若弧<v, v'>属于E，则
    - 顶点v邻接到v' (注意和无向图称呼的区别)
    - 顶点v'邻接自v的弧<v, v'>与顶点v和v'相关联
- 入度
    - 以顶点v为头的弧的数据，记为ID(v)
- 出度
    - 以顶点v为尾部的弧的数据，记为OD(v)
- 度
    - v的度为 TD(v)=ID(v)+OD(v)


### 路径
- 从顶点v到v'的路径是一个顶点序列
- 路径的长度
    > 路径上的边或者弧的长度（有向图的路径也是有向的）
- 回路/环
    > 从第一个顶点到最后一个顶点的路径
- 简单路径
    > 序列中顶点不重复的路径
- 简单回路/环
    > 除了第一个顶点和最后一个顶点之外，其余顶点都不重复出现的回路

### 连通图
- 在无向图中，若从顶点v到v'有路径，则称v和v'是连通的（若有向图，则从v到v'的路径中所有边是同向的）
- 若图G中任意两个顶点都是连通的，则称G为连通图（若为有向图，则称之为强连通图）

### 连通分量
> 无向图中极大连通子图


## 图的存储结构
### 邻接矩阵
> 使用矩阵描述图中顶点之间的关系（及弧或者边的权值）。缺点是占用空间大
- 有向图
- 无向图
### 邻接表
> 链式存储方式，相对邻接矩阵省空间。但不方便判断两顶点间是否有边
- 无向图
- 有向图


## 图的遍历
> 从图的任意一个顶点出发，对图中所有顶点访问一次且只访问一次。图的遍历操作和树的遍历操作功能相似。图的遍历是图的一种基本操作，图的其他算法，如求解连通性问题，拓扑排序，求关键路径等都是建立在遍历算法的基础上的。
- 图结构的复杂性导致其遍历操作的复杂性，主要体现在以下几个方面
    1. 在图结构中，没有一个自然首节点，图中任意一个顶点都可以作为首节点。
    2. 在非连通图中，从一个顶点出发，仅仅能够访问它所在的连通分量上的所有顶点。因此还需要考虑如何选取下一个出发点来访问其余的连通分量。
    3. 在图结构中，若存在回路，则一个顶点被访问之后，有可能回路返回该顶点
    4. 图结构中，一个顶点可以和其他多个顶点相连，当该顶点被访问后，需要考虑如何访问下一个顶点的问题

### 深度优先遍历 Depth First Search
> 类似于树的先序遍历
- 从图中某个顶点v开始访问，随后再访问未被访问过的邻接点，以当前邻接点作为新的起点继续访问，直到图中所有和v有路径相通的顶点都被访问到。若此时图中还存在未被访问过的顶点，则另外选择图中未曾被访问过的顶点作为起始点，重复以上流程，直到所有的顶点都被访问到为止

### 广度优先遍历 Breadth First Search
> 类似于树的按层次遍历
- 从图中某个顶点v开发访问，随后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问他们的邻接点，并使"先被访问的邻接点"先于"后被访问的顶点的邻接点"被访问(队列实现吧)，直到图中所有已被访问过的顶点的邻接点都被访问过。若此时图中还存在未被访问过的顶点，则另选择图中未曾被访问过的顶点作为起始点，重复上述过程。直到所有的顶点都被访问到为止。
